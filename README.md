# aiotool

All-In-One tool bot.

### Описание API

#### Разное
* "Модули" теперь называются "расширениями" (extensions) чтобы не происходило лишней путаницы
с модулями бота и модулями питона при дальнейшем описании API.
#### Обёртка над стейтами aiogram
В aiotools был обёрнут встроенный функционал FSM в библиотеке телеграма для значительного сокращения кода.

Все использование FSM (в большинстве случаев, наверное) теперь сводится к использованию т.н. "функций"

Функцией назван декоратор у формы (в нашей обертке WrappedStatesGroup), который принимает
в себя функцию-колл*бек*, вызывающуюся при окончании всех стейтов и предоставляющую все данные полученные
при выполнении стейтов.

Сама форма так же как и в оригинале заполняется класс-атрибутами в виде объектов WrappedState.
Обёрнутые стейты, в отличие от обычных, являются объектами, которые самостоятельно обрабатываюют
сообщения, задают свои значения и **регистрируют для себя хандлеры**. Обёрнутые стейты имеют своё описание, которое выводится
пользователю при активации стейта. Обёрнутые стейты так же могут быть опциональными, что позволяет
юзеру пропустить их заполнение и перейти к следующему состоянию.

Вышеупомянутые меры все еще недостаточно укорачивают код, по этому существует обёртка над обёрткой -
автостейты. В случае с ними необходимость самому имплементировать методы, обрабатывающие значения, отсутствует.

В апи существует определенный набор автостейтов, каждый из них парсит свой тип данных или еще что-то в этом роде.
Пример - AutoIntState заменяет простые, но достаточно ёмкие действия одной строчкой кода.

Тем не менее, иногда мало просто распарсить какое-то значение, иногда нужно проверить его на какие-то
условия. В таком случае существует декоратор `@value_checker` в базовом классче всех автостейтов. Данный декоратор
можно использовать прямо в классе формы, при возвращении методом `True` выполнение стейтов останется неизменным,
в обратном случае не произойдет ничего, и текущимй стейт останется таким же.

#### WrappedState
Для того чтобы все-таки написать свой стейт с нуля, нужно наследоваться от этого класса и ознакомиться с тем,
как работают 2 метода ниже. Возможно эти знания также пригодятся и при наследовании от AutoState, если надобность
в этом вообще будет.

* `on_state`: метод непосредственной обработки сообщения. Должен вернуть enum StateResult или None, это значение 
сообщит хандлеру что делать дальше - ничего, перейти к следующему стейту, или закончить все стейты (и вызвать финальный
коллбек)
* `on_pro_state`: этот метод - именно тот, который вызывается в авто-зарегестрированном хендлере стейта, а не предыдущий.
В родительском классе этот метод просто выполняет вышеупомянутый метод и возвращает результат. В условиях наследования
есть следующие примеры использования этого метода:
    * Досрочно пропустить стейт. Например, нам нужно получить из этого состояния значения только при каком-то условии, не всегда.
    * Что-то сделать со значением уже после выполнения стейта. Повлиять на выполнение следующих стейтов основываясь на нем. 
  (пример этого есть в AutoState)
* `registed_handler`: здесь происходит регистрация хандлеров для стейта. Менять это нужно в крайнем случае, наверное